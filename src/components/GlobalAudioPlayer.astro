<!--
  GlobalAudioPlayer.astro
  
  Global audio player component for seamless music playback across pages.
  Features play/pause controls, progress tracking, volume control, and track information.
  Persists during page transitions and manages global audio state throughout the site.
-->

<div id="global-audio-player" class="global-audio-player hidden" style="view-transition-name: global-audio-player;">
  <div class="player-content">
    <div class="track-info">
      <span class="track-title" id="current-track-title">No track selected</span>
      <span class="track-artist" id="current-track-artist"></span>
    </div>
    
    <div class="player-controls">
      <button class="control-btn" id="play-pause-btn">
        <svg class="play-icon" width="24" height="24" viewBox="0 0 24 24">
          <path d="M8 5v14l11-7z"/>
        </svg>
        <svg class="pause-icon" width="24" height="24" viewBox="0 0 24 24" style="display: none;">
          <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
        </svg>
      </button>
    </div>
    
    <div class="progress-section">
      <div class="time-display">
        <span id="current-time">0:00</span>
      </div>
      <div class="progress-container">
        <input 
          type="range" 
          id="progress-slider" 
          min="0" 
          max="100" 
          value="0" 
          class="progress-slider"
        />
      </div>
      <div class="time-display">
        <span id="duration">0:00</span>
      </div>
    </div>
    
    <div class="volume-section">
      <button class="control-btn" id="volume-btn">
        <svg class="volume-icon" width="20" height="20" viewBox="0 0 24 24">
          <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
        </svg>
      </button>
      <input 
        type="range" 
        id="volume-slider" 
        min="0" 
        max="100" 
        value="70" 
        class="volume-slider"
      />
    </div>
    
    <button class="control-btn close-btn" id="close-player-btn">
      <svg width="20" height="20" viewBox="0 0 24 24">
        <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
      </svg>
    </button>
  </div>
  
  <audio 
    id="global-audio" 
    preload="none"
    playsinline
    controlslist="nodownload"
  ></audio>
</div>

<style lang="scss">
  @use '../styles/helpers/responsive' as *;
  @use '../styles/helpers/colors' as *;
  @use '../styles/helpers/fonts' as *;

  .global-audio-player {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 1000;
    @include bg-color('bg-primary');
    border-bottom: 1px solid var(--color-border);
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    view-transition-name: global-audio-player;
    
    .player-content {
      display: flex;
      align-items: center;
      gap: 1.5rem;
      padding: 1rem 2rem;
      max-width: 1200px;
      margin: 0 auto;
      
      @include media-up('xl') {
        max-width: 1400px;
        gap: 2rem;
      }
      
      @include media-up('xxl') {
        max-width: 1600px;
        gap: 2.5rem;
      }
      
      @include media-down('md') {
        gap: 1rem;
        padding: 0.25rem 1rem 0.5rem 1rem;
        flex-wrap: wrap;
        position: relative;
        min-height: 80px;
      }
    }
    
    .track-info {
      flex: 1;
      min-width: 200px;
      
      .track-title {
        display: block;
        @include font-size('base');
        @include font-weight('semibold');
        @include text-color('text-primary');
        margin-bottom: 0.25rem;
      }
      
      .track-artist {
        display: block;
        @include font-size('sm');
        @include text-color('text-secondary');
      }
      
      @include media-down('md') {
        order: 2;
        width: calc(100% - 120px);
        text-align: center;
        margin: 0 auto;
        position: absolute;
        left: 60px;
        right: 60px;
        top: 50%;
        transform: translateY(-50%);
      }
    }
    
    .player-controls {
      @include media-down('md') {
        order: 1;
        position: absolute;
        left: 1rem;
        top: 50%;
        transform: translateY(-50%);
      }
    }
    
    .progress-section {
      display: flex;
      align-items: center;
      gap: 1rem;
      flex: 2;
      min-width: 300px;
      
      @include media-up('lg') {
        flex: 3;
        min-width: 400px;
        gap: 1.25rem;
      }
      
      @include media-up('xl') {
        flex: 4;
        min-width: 500px;
        gap: 1.5rem;
      }
      
      @include media-down('md') {
        order: 4;
        width: 100%;
        margin: 4rem 0 0 0;
        position: static;
        transform: none;
      }
      
      .time-display {
        @include font-size('sm');
        @include text-color('text-secondary');
        @include font-weight('medium');
        min-width: 40px;
      }
      
      .progress-container {
        flex: 1;
      }
    }
    
    .volume-section {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      
      @include media-down('md') {
        display: none;
      }
      
      .volume-slider {
        width: 80px;
        
        @include media-down('md') {
          width: 60px;
        }
      }
    }
    
    .control-btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 0.5rem;
      border-radius: 50%;
      @include text-color('text-primary');
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      
      &:hover {
        @include bg-color('bg-secondary');
      }
      
      &:active {
        transform: scale(0.95);
      }
      
      &.needs-resume {
        animation: pulse-resume 1.5s infinite;
        background: var(--color-primary);
        color: white;
        
        &:hover {
          background: var(--color-primary-hover, var(--color-primary));
        }
      }
      
      svg {
        fill: currentColor;
      }
    }
    
    .close-btn {
      @include media-down('md') {
        order: 3;
        position: absolute;
        right: 1rem;
        top: 50%;
        transform: translateY(-50%);
      }
    }
    
    .progress-slider,
    .volume-slider {
      -webkit-appearance: none;
      height: 6px;
      border-radius: 3px;
      @include bg-color('border-light');
      outline: none;
      cursor: pointer;
      
      &::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--color-primary);
        cursor: pointer;
        transition: all 0.2s ease;
        
        &:hover {
          transform: scale(1.2);
        }
      }
      
      &::-moz-range-thumb {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--color-primary);
        cursor: pointer;
        border: none;
        transition: all 0.2s ease;
        
        &:hover {
          transform: scale(1.2);
        }
      }
    }
    
    .progress-slider {
      width: 100%;
    }
  }

  .hidden {
    display: none;
  }

  @keyframes pulse-resume {
    0%, 100% {
      opacity: 1;
      transform: scale(1);
    }
    50% {
      opacity: 0.8;
      transform: scale(1.05);
    }
  }
</style>

<script is:inline>
// Global Audio Player Controller
class GlobalAudioPlayer {
  constructor() {
    this.audio = null;
    this.isPlaying = false;
    this.currentTrack = null;
    this.playerElement = null;
    this.eventListenersSetup = false;
    this.init();
  }

  init() {
    // Wait for DOM to be ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => this.setupPlayer());
    } else {
      this.setupPlayer();
    }
    
    // Handle view transitions
    this.setupViewTransitionHandlers();
  }

  setupViewTransitionHandlers() {
    // Save state before page change
    document.addEventListener('astro:before-swap', () => {
      this.saveTransitionState();
    });
    
    // Restore state after page change
    document.addEventListener('astro:after-swap', () => {
      this.restoreAfterTransition();
    });
  }

  saveTransitionState() {
    if (this.currentTrack && this.audio) {
      const state = {
        track: this.currentTrack,
        currentTime: this.audio.currentTime,
        duration: this.audio.duration,
        isPlaying: this.isPlaying,
        volume: this.audio.volume,
        isVisible: !this.playerElement.classList.contains('hidden'),
        wasPlaying: !this.audio.paused
      };
      sessionStorage.setItem('globalAudioTransitionState', JSON.stringify(state));
      
      // Also pause the audio to prevent it from continuing on the old page
      if (!this.audio.paused) {
        this.audio.pause();
      }
    }
  }

  restoreAfterTransition() {
    // Wait a bit for the new DOM to be ready
    setTimeout(() => {
      // Re-setup the player completely
      this.eventListenersSetup = false; // Reset flag to allow new setup
      this.setupPlayer();
      
      const savedState = sessionStorage.getItem('globalAudioTransitionState');
      if (savedState) {
        try {
          const state = JSON.parse(savedState);
          
          this.currentTrack = state.track;
          this.updateTrackInfo(state.track);
          
          if (state.isVisible) {
            this.showPlayer();
          }
          
          // Load the audio source
          this.audio.src = state.track.url;
          
          // Wait for audio to be ready, then restore position and play state
          const onCanPlay = () => {
            this.audio.currentTime = state.currentTime || 0;
            this.audio.volume = state.volume || 0.7;
            
            if (state.wasPlaying || state.isPlaying) {
              // Show resume indicator immediately
              this.showResumeIndicator();
              this.isPlaying = false; // Set to false initially
              this.updatePlayPauseButton();
            } else {
              this.isPlaying = false;
              this.updatePlayPauseButton();
            }
            
            this.audio.removeEventListener('canplay', onCanPlay);
          };
          
          this.audio.addEventListener('canplay', onCanPlay);
          
        } catch (e) {
          console.error('Error restoring audio state after transition:', e);
        }
      }
    }, 150); // Slightly longer delay to ensure DOM is ready
  }

  setupPlayer() {
    this.playerElement = document.getElementById('global-audio-player');
    this.audio = document.getElementById('global-audio');
    
    if (!this.playerElement || !this.audio) {
      // Elements not ready yet, try again in a moment
      setTimeout(() => this.setupPlayer(), 50);
      return;
    }

    // Setup event listeners
    this.setupEventListeners();
    this.setupAudioEventListeners();
    
    // Restore state from localStorage if available (only on initial load)
    if (!sessionStorage.getItem('globalAudioTransitionState')) {
      this.restoreState();
    }
  }

  setupEventListeners() {
    if (this.eventListenersSetup) return;
    
    const playPauseBtn = document.getElementById('play-pause-btn');
    const progressSlider = document.getElementById('progress-slider');
    const volumeSlider = document.getElementById('volume-slider');
    const closeBtn = document.getElementById('close-player-btn');

    this.playPauseHandler = () => this.togglePlayPause();
    this.progressHandler = (e) => this.seekTo(e.target.value);
    this.volumeHandler = (e) => this.setVolume(e.target.value);
    this.closeHandler = () => this.closePlayer();

    if (playPauseBtn) playPauseBtn.addEventListener('click', this.playPauseHandler);
    if (progressSlider) progressSlider.addEventListener('input', this.progressHandler);
    if (volumeSlider) volumeSlider.addEventListener('input', this.volumeHandler);
    if (closeBtn) closeBtn.addEventListener('click', this.closeHandler);
    
    this.eventListenersSetup = true;
  }

  removeEventListeners() {
    if (!this.eventListenersSetup) return;
    
    const playPauseBtn = document.getElementById('play-pause-btn');
    const progressSlider = document.getElementById('progress-slider');
    const volumeSlider = document.getElementById('volume-slider');
    const closeBtn = document.getElementById('close-player-btn');

    if (playPauseBtn) playPauseBtn.removeEventListener('click', this.playPauseHandler);
    if (progressSlider) progressSlider.removeEventListener('input', this.progressHandler);
    if (volumeSlider) volumeSlider.removeEventListener('input', this.volumeHandler);
    if (closeBtn) closeBtn.removeEventListener('click', this.closeHandler);
    
    this.eventListenersSetup = false;
  }

  setupAudioEventListeners() {
    this.audio.addEventListener('loadedmetadata', () => this.updateDuration());
    this.audio.addEventListener('timeupdate', () => this.updateProgress());
    this.audio.addEventListener('ended', () => this.onTrackEnded());
  }

  async loadTrack(track) {
    
    // If player was closed, make sure it's properly set up
    if (!this.currentTrack && this.playerElement.classList.contains('hidden')) {
      // Make sure event listeners are set up
      if (!this.eventListenersSetup) {
        this.setupEventListeners();
      }
    }
    
    // If a different track is being loaded, stop the current one
    if (this.currentTrack && this.currentTrack.url !== track.url) {
      this.pause();
      this.audio.currentTime = 0;
    }
    
    this.currentTrack = track;
    this.updateTrackInfo(track);
    this.showPlayer();
    this.removeResumeIndicator();
    
    // Load the new audio source
    this.audio.src = track.url;
    
    // Try to play immediately to preserve user gesture
    try {
      await this.play();
      this.saveState();
      return true; // Successfully started playing
    } catch (error) {
      // If immediate play fails, wait for canplay and try again
      return new Promise((resolve) => {
        const onCanPlay = async () => {
          this.audio.removeEventListener('canplay', onCanPlay);
          try {
            await this.play();
            resolve(true); // Successfully started playing after load
          } catch (secondError) {
            // If auto-play still fails, show resume indicator
            this.isPlaying = false;
            this.updatePlayPauseButton();
            this.showResumeIndicator();
            resolve(false); // Playback failed, user needs to manually start
          }
        };
        
        this.audio.addEventListener('canplay', onCanPlay);
        
        // Save state after setting up the track
        this.saveState();
      });
    }
  }

  async tryAutoPlay() {
    try {
      await this.play();
    } catch (error) {
      // If auto-play fails, just ensure the player is ready
      this.isPlaying = false;
      this.updatePlayPauseButton();
    }
  }

  updateTrackInfo(track) {
    const titleEl = document.getElementById('current-track-title');
    const artistEl = document.getElementById('current-track-artist');
    
    if (titleEl) titleEl.textContent = track.title || 'Unknown Track';
    if (artistEl) artistEl.textContent = track.artist || '';
  }

  showResumeIndicator() {
    const playPauseBtn = document.getElementById('play-pause-btn');
    if (playPauseBtn) {
      playPauseBtn.classList.add('needs-resume');
      playPauseBtn.title = 'Click to resume playback';
    }
  }

  removeResumeIndicator() {
    const playPauseBtn = document.getElementById('play-pause-btn');
    if (playPauseBtn) {
      playPauseBtn.classList.remove('needs-resume');
      playPauseBtn.title = '';
    }
  }

  async togglePlayPause() {
    
    if (this.isPlaying) {
      this.pause();
    } else {
      try {
        await this.play();
        this.removeResumeIndicator();
      } catch (error) {
        console.error('Playback failed:', error);
      }
    }
  }

  async play() {
    await this.audio.play();
    this.isPlaying = true;
    this.updatePlayPauseButton();
    this.saveState();
  }

  pause() {
    this.audio.pause();
    this.isPlaying = false;
    this.updatePlayPauseButton();
    this.saveState();
  }

  updatePlayPauseButton() {
    const playIcon = document.querySelector('.play-icon');
    const pauseIcon = document.querySelector('.pause-icon');
    
    if (this.isPlaying) {
      if (playIcon) playIcon.style.display = 'none';
      if (pauseIcon) pauseIcon.style.display = 'block';
    } else {
      if (playIcon) playIcon.style.display = 'block';
      if (pauseIcon) pauseIcon.style.display = 'none';
    }
  }

  seekTo(percentage) {
    const time = (percentage / 100) * this.audio.duration;
    this.audio.currentTime = time;
  }

  setVolume(percentage) {
    this.audio.volume = percentage / 100;
    localStorage.setItem('globalAudioVolume', percentage);
  }

  updateProgress() {
    if (this.audio.duration) {
      const percentage = (this.audio.currentTime / this.audio.duration) * 100;
      const progressSlider = document.getElementById('progress-slider');
      const currentTimeEl = document.getElementById('current-time');
      
      if (progressSlider) progressSlider.value = percentage;
      if (currentTimeEl) currentTimeEl.textContent = this.formatTime(this.audio.currentTime);
    }
  }

  updateDuration() {
    const durationEl = document.getElementById('duration');
    if (durationEl) durationEl.textContent = this.formatTime(this.audio.duration);
  }

  formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }

  showPlayer() {
    // If already visible, don't animate again
    if (!this.playerElement.classList.contains('hidden')) {
      return;
    }
    
    // Remove hidden class but keep elements invisible for animation
    this.playerElement.classList.remove('hidden');
    
    const playerContent = this.playerElement.querySelector('.player-content');
    if (!playerContent) return;
    
    // Temporarily show content to measure its natural height
    playerContent.style.opacity = '0';
    this.playerElement.style.height = 'auto';
    this.playerElement.style.overflow = 'hidden';
    
    // Get the natural height of the player
    const naturalHeight = this.playerElement.offsetHeight;
    
    // Now set initial state: collapsed height, invisible content
    this.playerElement.style.height = '0px';
    playerContent.style.opacity = '0';
    
    // Adjust body padding immediately to prevent content jump
    document.body.style.paddingTop = naturalHeight + 'px';
    
    // Use anime.js for the animation sequence
    if (typeof anime !== 'undefined') {
      // Create animation timeline
      const tl = anime.timeline({
        easing: 'easeOutCubic'
      });
      
      // Phase 1: Expand height from 0 to natural height
      tl.add({
        targets: this.playerElement,
        height: ['0px', naturalHeight + 'px'],
        duration: 400,
        easing: 'easeOutCubic'
      });
      
      // Phase 2: Fade in content elements
      tl.add({
        targets: playerContent,
        opacity: [0, 1],
        duration: 300,
        easing: 'easeOutQuad',
        complete: () => {
          // Clean up inline styles after animation
          this.playerElement.style.height = '';
          this.playerElement.style.overflow = '';
          playerContent.style.opacity = '';
        }
      }, '-=100'); // Start slightly before height animation ends
      
    } else {
      // Fallback if anime.js is not available
      this.playerElement.style.height = '';
      this.playerElement.style.overflow = '';
      playerContent.style.opacity = '';
    }
  }

  closePlayer() {
    this.pause();
    
    const playerContent = this.playerElement.querySelector('.player-content');
    
    // Use anime.js for the closing animation sequence
    if (typeof anime !== 'undefined') {
      // Create animation timeline for closing
      const tl = anime.timeline({
        easing: 'easeInCubic',
        complete: () => {
          // Clean up after animation
          this.playerElement.classList.add('hidden');
          document.body.style.paddingTop = '0';
          
          // Reset inline styles
          this.playerElement.style.height = '';
          this.playerElement.style.overflow = '';
          if (playerContent) {
            playerContent.style.opacity = '';
          }
          
          // Reset audio state
          this.currentTrack = null;
          this.audio.src = '';
          this.audio.currentTime = 0;
          this.isPlaying = false;
          this.removeResumeIndicator();
          this.updatePlayPauseButton();
          
          // Clear stored states
          localStorage.removeItem('globalAudioState');
          sessionStorage.removeItem('globalAudioTransitionState');
        }
      });
      
      // Phase 1: Fade out content
      tl.add({
        targets: playerContent,
        opacity: [1, 0],
        duration: 200,
        easing: 'easeInQuad'
      });
      
      // Phase 2: Collapse height
      tl.add({
        targets: this.playerElement,
        height: [this.playerElement.offsetHeight + 'px', '0px'],
        duration: 300,
        easing: 'easeInCubic',
        begin: () => {
          this.playerElement.style.overflow = 'hidden';
          document.body.style.paddingTop = '0';
        }
      }, '-=50'); // Start slightly before fade out ends
      
    } else {
      // Fallback if anime.js is not available
      this.playerElement.classList.add('hidden');
      document.body.style.paddingTop = '0';
      
      // Reset audio state
      this.currentTrack = null;
      this.audio.src = '';
      this.audio.currentTime = 0;
      this.isPlaying = false;
      this.removeResumeIndicator();
      this.updatePlayPauseButton();
      
      // Clear stored states
      localStorage.removeItem('globalAudioState');
      sessionStorage.removeItem('globalAudioTransitionState');
    }
  }

  onTrackEnded() {
    this.isPlaying = false;
    this.updatePlayPauseButton();
    this.saveState();
  }

  saveState() {
    if (this.currentTrack) {
      const state = {
        track: this.currentTrack,
        currentTime: this.audio.currentTime,
        isPlaying: this.isPlaying,
        volume: this.audio.volume
      };
      localStorage.setItem('globalAudioState', JSON.stringify(state));
    }
  }

  restoreState() {
    const savedState = localStorage.getItem('globalAudioState');
    const savedVolume = localStorage.getItem('globalAudioVolume');
    
    if (savedVolume) {
      this.setVolume(savedVolume);
      const volumeSlider = document.getElementById('volume-slider');
      if (volumeSlider) volumeSlider.value = savedVolume;
    }
    
    if (savedState) {
      try {
        const state = JSON.parse(savedState);
        this.currentTrack = state.track;
        this.audio.src = state.track.url;
        this.audio.currentTime = state.currentTime || 0;
        this.updateTrackInfo(state.track);
        this.showPlayer();
        
        if (state.isPlaying) {
          // Don't auto-play on page load, just show as paused
          this.isPlaying = false;
          this.updatePlayPauseButton();
        }
      } catch (e) {
        console.error('Error restoring audio state:', e);
      }
    }
  }
}

// Initialize global audio player
if (typeof window !== 'undefined') {
  window.globalAudioPlayer = new GlobalAudioPlayer();

  // Global function to load track from anywhere
  window.loadGlobalTrack = async function(track) {
    if (window.globalAudioPlayer) {
      const playbackStarted = await window.globalAudioPlayer.loadTrack(track);
      if (!playbackStarted) {
        // Optionally could add some user feedback here
        // For now, the resume indicator will show
      }
    } else {
      console.error('globalAudioPlayer not initialized');
    }
  };
}
</script>
